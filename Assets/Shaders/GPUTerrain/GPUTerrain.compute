#pragma kernel TerrainNodeBuild
#pragma kernel TerrainLODMap
#pragma kernel TerrainVisibleRender

#include "./GPUTerrainUtility.hlsl"

AppendStructuredBuffer<uint2> appendNodeList;   // first A
ConsumeStructuredBuffer<uint2> consumeNodeList; // first B
AppendStructuredBuffer<uint3> appendFinalNodeList;    // result

//QuadTreeBuild
uniform float4 _worldParams;
uniform uint _curLodLevel;

uniform float3 _cameraPos;
uniform float4 _cameraFrustumPlanes[6];

uniform float4 _nodeEvaluationC;

//Lod Map

//RenderPatchList
StructuredBuffer<uint3> finalNodeList;
AppendStructuredBuffer<RenderPatch> culledPatchList;

bool CalcuteSubdivide(uint2 node)
{
    float3 nodePositionWS = GetNodeWorldPosition(node, _curLodLevel);
    //TODO: Currently we move camerapos to xz plane
    float3 cameraPos = float3(_cameraPos.x,0,_cameraPos.z);
    float dist = distance(cameraPos, nodePositionWS);
    //float dist = max(abs(cameraPos.x-nodePositionWS.x),abs(cameraPos.z-nodePositionWS.z));
    float nodeSize = GetNodeSize(_curLodLevel);
    float f = dist / (nodeSize * _nodeEvaluationC.x);
    if( f < 1.0f )
        return true;
    return false;
}

[numthreads(1,1,1)]
void TerrainNodeBuild (uint3 id : SV_DispatchThreadID)
{
    uint2 curNode = consumeNodeList.Consume();
    
    [branch]
    if(_curLodLevel > 0 && CalcuteSubdivide(curNode))
    {
        appendNodeList.Append(curNode * 2);
        appendNodeList.Append(curNode * 2 + uint2(1,0));
        appendNodeList.Append(curNode * 2 + uint2(0,1));
        appendNodeList.Append(curNode * 2 + uint2(1,1));
    }
    else
    {
        appendFinalNodeList.Append(uint3(curNode, _curLodLevel));
    }
}

[numthreads(1,1,1)]
void TerrainLODMap (uint3 id : SV_DispatchThreadID)
{

}

bool Cull(Bound bound)
{
    return false;
}

RenderPatch CreatePatch(uint3 node, uint2 patchId)
{

}

Bound CreateBound(uint3 node, uint2 patch)
{

}

[numthreads(8,8,1)]
void TerrainVisibleRender (uint3 id : SV_DispatchThreadID, uint3 groupId:SV_GroupID, uint3 groupThreadId:SV_GroupThreadID)
{
    // // uint3 node = finalNodeList[groupId];
    // // uint2 patchId = groupThreadId.xy;

    // // //Build RenderPatch
    // // RenderPathch patch = CreatePatch(node, patchId);

    // // //Build Bound do Culling
    // // //Bound bound = CreateBound(patch);
    // // Bound bound = CreateBound(node, patchId);

    // // if(Cull(bound))
    // //     return;
    
    // culledPatchList.Append()
}